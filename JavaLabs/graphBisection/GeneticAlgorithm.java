// (C) Prof. Lixin Tao, Pace University, September 2003
import java.util.Random;

// A simplified generic algorithm implementation for graph bisection
public class GeneticAlgorithm {

  private int vertexNumber;             // Vertex number of a graph
  private Random r;                     // Random number generator
  private Utilities u = null;           // Utilities object

  // Parameters to be adjusted for better performance
  private int generationSize = 50;      // Number of members in a generation
  private int crossoverNumber = 40;     // Number of children to be generated by crossover
  private int mutateNumber = 10;        // Number of children to be generated by mutation
  
  private Object[] generation;          // Table of members of a generation, sorted by cut sizes
  private int p[];                      // Generic array for storing a partition
  IndexedFloat sortingArray[];          // An array for sorting (member[i], i) pairs in convertSolution()
  
  // Use genetic algorithm to find the smallest cut size
  // bestPartition[] is space for reporting back best partition
  // u is a reference for a Utilities object
  public int run(int bestPartition[], Utilities u) {
    this.u = u;
    vertexNumber = u.getVertexNumber();   // Retrieve vertex number of the graph
    r = u.getRandom();                    // Retrieve the Random object
    p = new int[vertexNumber];            // Allocate space for a partition
    // Allocate space for sortingArray for sorting (member[i], i) pairs in convertSolution()
    sortingArray = new IndexedFloat[vertexNumber];
    // Generate reusable IndexedFloat objects with fake values; used in convertSolution()
    for (int i = 0; i < vertexNumber; i++)
      sortingArray[i] = new IndexedFloat(0.0f, 0);
    
    // Best cut size seen so far
    // Initialized to be impossibly large so it will be replaced in loop iteration 1
    int bestCost = Integer.MAX_VALUE;                              
    generation = new Object[generationSize];       // Allocate space for generation table
    generateInitialGeneration();                   // Generate the initial generation of members
    // Generate 50 new generations, and report the best partition
    // Better implementation: terminate the loop if no solution improvement
    // for some consecutive generations
    for (int i = 1; i <= 50; i++) {
      // Perform crossover for crossoverNumber times
      // For each crossover, parent 2 contributes up to half of the child's values
      crossover(crossoverNumber, vertexNumber/2);  //  vertexNumber/2 should be adjusted
      // Perform mutation for mutateNumber times
      // For each child, up to a quarter of parent's value will be modified
      mutate(mutateNumber, vertexNumber/4);        //  vertexNumber/4 should be adjusted
      // Retrieve the best member in current generation 
      float bestMember[] = (float[])generation[0];   
      // Last box holds the cut size
      int cost = (int)bestMember[vertexNumber];
      // If the best member improves the best cut size seen so far, record it
      if (cost < bestCost) {
        bestCost = cost;
        convertSolution(bestMember, p);  // Convert the member to its corresponding partition p
        u.copyArray(p, bestPartition);   // Copy p[] into bestPartition[]
      }
    }
    return bestCost;
  }

  // Create member space and random values for generation 0, sort the members based on cut sizes
  private void generateInitialGeneration() {
    for (int i = 0; i < generationSize; i++) {
      // Allocate space for a member
      // generation[*][vertexNumber] is the cut size of member generation[*]
      float member[] = new float[vertexNumber+1];
      // Populate member[0..vertexnumber-1] with random float numbers in [0.0, ..., 1)
      for (int j = 0; j < vertexNumber; j++)
        member[j] = r.nextFloat();
      // Evaluate and record the cut size of member
      member[vertexNumber] = cutSize(member);
      // Insert member into table slot generation[i], and make sure generation[0..i] is 
      // still sorted by cut sizes of its members
      insert(member, i);
    }
  }

  // generation[0..i-1] is already sorted relative to generation[0..i-1][vertexNumber]
  // Insert member at slot i and make generation[0..i] remain sorted
  void insert(float member[], int i) {
    generation[i] = member;
    // Ripple member up if necessary
    while ((i > 0) && ((float[])generation[i-1])[vertexNumber] > ((float[])generation[i])[vertexNumber]) {
      // Swap generation[i-1] and generation[i]
      Object temp = generation[i-1];
      generation[i-1] = generation[i];
      generation[i] = temp;
      i--;
    }
  }

  // Convert a member (float version of solution) to a partition (integer version of solution)
  // Vertices with values less than the median go to the left partition, others to the right one
  private void convertSolution(float member[], int p[]) {
    // Populate sortingArray[] with (member[i], i) pairs
    for (int i = 0; i < vertexNumber; i++) {
      IndexedFloat o = sortingArray[i];
      o.memberValue = member[i];
      o.index = i;
    }
    // Quicksort sortingArray[] based on float values member[*]
    java.util.Arrays.sort(sortingArray); 
    // First, assign all vertices to the right partition (partition 1)
    for (int i = 0; i < vertexNumber; i++)
      p[i] = 1;
    // For vertices with member values less than the median,
    // reassign them to the left partition (partition 0)
    for (int i = 0; i < vertexNumber/2; i++)
      p[sortingArray[i].index] = 0;  
  }

  // Evaluate and return the cut size of member
  private int cutSize(float member[]) {
    convertSolution(member, p);  // Convert member to a partition
    return u.cutSize(p);         // Evaluate and return the cut size of the partition
  }

  // Perform crossovers to generate numberOfNewChildren children
  // For each child member, up to maxNbrValuesFromParent2 values are randoomly chosen 
  // from parent 2, others from parent 1
  private void crossover(int numberOfNewChildren, int maxNbrValuesFromParent2) {
    // Generate up to numberOfNewChildren children; children may duplicate
    for (int i = 0; i < numberOfNewChildren; i++) {    
      int parent1 = r.nextInt(generationSize);       // Randomly choose parent1 
      int parent2 = r.nextInt(generationSize-1);     // Randomly choose parent2; avoid last member
      while (parent1 == parent2)                     // parent1 must differ from parent2
        parent2 = r.nextInt(generationSize-1);
      // Recycle space of the worst (last) member for new child
      float child[] = (float[])generation[generationSize-1]; 
      float temp[] = (float[])generation[parent1];   // temp is now parent1
      for (int j = 0; j < vertexNumber; j++)         // Copy parent1 to child
        child[j] = temp[j];
      temp = (float[])generation[parent2];           // temp is now parent2
      // Randomly copy up to maxNbrValuesFromParent2 values from parent2
      for (int l = 0; l < maxNbrValuesFromParent2; l++) { 
        int k = r.nextInt(vertexNumber);             // Randomly choose an index k
        child[k] = temp[k];                          // Copy parent2[k] to child[k]
      }
      child[vertexNumber] = cutSize(child);          // Set up cut size for the child
      insert(child, generationSize-1);               // Insert child into the sorted generation table
    }
  }

  // Perform mutations to generate numberOfNewChildren children
  // For each child member, up to mutatePosNumber values from its parent may be modified
  private void mutate(int numberOfNewChildren, int mutatePosNumber) {
    // Generate up to numberOfNewChildren children; children may duplicate
    for (int i = 0; i < numberOfNewChildren; i++) {
      int parent = r.nextInt(generationSize);
      // Recycle space of the worst (last) member for new child
      float child[] = (float[])generation[generationSize-1]; 
      float temp[] = (float[])generation[parent];    // temp is now the parent
      for (int j = 0; j < vertexNumber; j++)
        child[j] = temp[j];                          // child is now the same as parent
      for (int l = 0; l < mutatePosNumber; l++) {    // Randomly modify up to mutatePosNumber values
        int k = r.nextInt(vertexNumber);
        child[k] = r.nextFloat(); 
      }
      child[vertexNumber] = cutSize(child);          // Set up cut size for the child
      insert(child, generationSize-1);               // Insert child into the sorted generation table
    }
  }


  // main() is only used when you run "java GeneticAlgorithm [file name]"
  public static void main(String args[]) {
    Utilities u = new Utilities();                    // Create a Utilities object
    String fileName = "graph10.txt";                  // Default data file name
    if (args.length == 1)
      fileName = args[0];                             // Use command-line file name
    u.readGraph(fileName);                            // Read in graph data file
    //u.printGraph();                                 // Print out the parsed graph data
    int bestPartition[] = new int[u.getVertexNumber()]; // Allocate space for best partition
    GeneticAlgorithm ga = new GeneticAlgorithm();
    u.startRun();                                     // Mark the start of run
    int bestCost = ga.run(bestPartition, u);          // Run Genetic Algorithm
    u.endRun();                                       // Mark the end of run
    // Print out results
    u.reportResult("Genetic algorithm", bestCost, bestPartition); 
    // Append results in file costs.txt
    u.appendBestPartition("Genetic algorithm", bestCost, bestPartition);        
  }
}

// A utility class for sorting (member[i], i) pairs
class IndexedFloat implements Comparable {
  int   index;          // index for member[]; accessible by classes in the same package
  float memberValue;    // member[index]; accessible by classes in the same package

  // Constructor
  public IndexedFloat(float memberValue, int index) {
    this.memberValue = memberValue;
    this.index = index;
  }

  // Return -1 if this object's memberValue is smaller than that of object o
  // Return 1 if this object's memberValue is larger than that of object o
  // Return 0 if this object's memberValue is equal to that of object o
  // This method is required by Java interface Comparable
  // Quicksort uses this method to make comparisons
  public int compareTo(Object o) {
    float delta = this.memberValue - ((IndexedFloat)o).memberValue;
    if (delta > 0.0f)
      return 1;
    else if (delta == 0.0f)
      return 0;
    else
      return -1;
  }
}